<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RevoLab Simulator | Industrial Robotics</title>
    
    <!-- Three.js Core & Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/math/ConvexHull.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/ConvexGeometry.js"></script>

    <style>
        :root {
            --bg-app: #0a0a0a;
            --bg-panel: #141414;
            --bg-input: #1f1f1f;
            --border-color: #333333;
            --accent-primary: #ff9100;
            --accent-hover: #ffb74d;
            --accent-dim: rgba(255, 145, 0, 0.15);
            --text-main: #e0e0e0;
            --text-muted: #757575;
            --text-highlight: #ffffff;
            --status-ok: #00e676;
            --status-warn: #ffea00;
            --status-err: #ff1744;
            --font-ui: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'JetBrains Mono', 'Consolas', monospace;
        }

        * { box-sizing: border-box; user-select: none; }

        body { margin: 0; background-color: var(--bg-app); color: var(--text-main); font-family: var(--font-ui); overflow: hidden; height: 100vh; display: flex; }

        #app-container { display: flex; width: 100%; height: 100%; }
        #sidebar { width: 420px; background-color: var(--bg-panel); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; z-index: 10; box-shadow: 10px 0 30px rgba(0,0,0,0.5); }
        #viewport { flex-grow: 1; position: relative; background: radial-gradient(circle at center, #1a1a1a 0%, #000000 120%); overflow: hidden; }

        /* Components */
        .header { padding: 20px; border-bottom: 1px solid var(--border-color); background: linear-gradient(180deg, #1a1a1a 0%, var(--bg-panel) 100%); }
        .header h1 { margin: 0; font-size: 18px; font-weight: 800; letter-spacing: 2px; color: var(--accent-primary); text-transform: uppercase; display: flex; align-items: center; gap: 10px; }
        .header h1::before { content: ''; display: block; width: 12px; height: 12px; background: var(--accent-primary); box-shadow: 0 0 10px var(--accent-primary); border-radius: 50%; }
        .header h2 { margin: 5px 0 0 22px; font-size: 11px; color: var(--text-muted); letter-spacing: 1px; font-weight: 400; }

        .tabs { display: flex; background: #0f0f0f; border-bottom: 1px solid var(--border-color); }
        .tab-btn { flex: 1; padding: 15px 0; background: transparent; border: none; color: var(--text-muted); font-size: 11px; font-weight: 600; text-transform: uppercase; cursor: pointer; transition: all 0.2s ease; border-bottom: 2px solid transparent; }
        .tab-btn:hover { color: var(--text-main); background: #1a1a1a; }
        .tab-btn.active { color: var(--accent-primary); border-bottom-color: var(--accent-primary); background: var(--accent-dim); }

        .tab-content { flex: 1; overflow-y: auto; overflow-x: hidden; position: relative; }
        .panel { display: none; padding: 20px; animation: slideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
        .panel.active { display: block; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .control-section { background: #181818; border: 1px solid var(--border-color); border-radius: 6px; padding: 15px; margin-bottom: 15px; }
        .section-title { font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; }

        .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 8px; }
        label { font-size: 12px; color: var(--text-muted); min-width: 60px; }
        
        input[type="number"], input[type="text"], select { background: var(--bg-input); border: 1px solid var(--border-color); color: var(--text-main); padding: 8px; border-radius: 4px; width: 100%; font-family: var(--font-mono); font-size: 12px; outline: none; transition: border-color 0.2s; }
        input:focus, select:focus { border-color: var(--accent-primary); box-shadow: 0 0 0 1px var(--accent-dim); }
        
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; border-radius: 2px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--text-main); border: 2px solid var(--bg-panel); border-radius: 50%; cursor: pointer; transition: transform 0.1s, background 0.2s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); background: var(--accent-primary); }
        
        input[type="color"] { -webkit-appearance: none; border: none; width: 100%; height: 30px; cursor: pointer; background: transparent; padding: 0; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 4px; }
        
        input[type="checkbox"] { width: auto; }

        .btn-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 10px; }
        .btn-grid.tri { grid-template-columns: repeat(3, 1fr); }
        button { background: #252525; border: 1px solid transparent; color: var(--text-main); padding: 10px 15px; border-radius: 4px; font-size: 11px; font-weight: 700; text-transform: uppercase; cursor: pointer; transition: all 0.2s; display: flex; justify-content: center; align-items: center; gap: 6px; }
        button:hover { background: #333; transform: translateY(-1px); }
        button.primary { background: var(--accent-primary); color: #000; }
        button.primary:hover { background: var(--accent-hover); box-shadow: 0 4px 15px var(--accent-dim); }
        button.danger { background: rgba(255, 23, 68, 0.1); color: #ff1744; border-color: rgba(255, 23, 68, 0.3); }
        button.danger:hover { background: rgba(255, 23, 68, 0.2); }

        .editor-wrapper { position: relative; border: 1px solid var(--border-color); background: #0f0f0f; border-radius: 4px; }
        textarea.code-area { width: 100%; height: 300px; background: transparent; border: none; color: #ffb74d; font-family: var(--font-mono); font-size: 12px; padding: 10px; resize: vertical; outline: none; line-height: 1.5; }
        
        /* Error Display */
        #error-box { background: rgba(255, 23, 68, 0.1); border: 1px solid #ff1744; border-radius: 4px; padding: 10px; margin-top: 10px; display: none; }
        .error-line { font-family: var(--font-mono); font-size: 11px; color: #ff8a80; margin-bottom: 4px; display: flex; gap: 8px; }
        .error-line span { font-weight: bold; }

        /* Plot Overlay */
        #plot-overlay { position: absolute; bottom: 20px; right: 20px; width: 300px; background: rgba(15, 15, 15, 0.9); backdrop-filter: blur(8px); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; pointer-events: auto; box-shadow: 0 5px 20px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 8px; }
        .plot-header { display: flex; justify-content: space-between; align-items: center; }
        .plot-title { font-size: 10px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .plot-controls { display: flex; gap: 4px; }
        .plot-controls button { padding: 4px 8px; font-size: 9px; min-width: auto; height: auto; }
        .plot-legend { display: flex; justify-content: space-between; font-size: 9px; font-family: var(--font-mono); color: #666; margin-top: 2px; }
        canvas#plot-canvas { width: 100%; height: 100px; background: #000; border-radius: 2px; border: 1px solid #333; display: block; }

        /* HUD */
        #hud-container { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: none; }
        .hud-panel { background: rgba(15, 15, 15, 0.85); backdrop-filter: blur(8px); border-left: 2px solid var(--accent-primary); padding: 10px 15px; border-radius: 0 4px 4px 0; min-width: 180px; }
        .hud-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .hud-value { font-family: var(--font-mono); font-size: 14px; color: var(--text-highlight); font-weight: 700; }
        .hud-value.accent { color: var(--accent-primary); }

        #toast-area { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: #1a1a1a; color: #fff; padding: 10px 20px; border-radius: 20px; font-size: 12px; border: 1px solid var(--border-color); box-shadow: 0 5px 20px rgba(0,0,0,0.5); display: flex; align-items: center; gap: 8px; opacity: 0; transform: translateY(10px); animation: popIn 0.3s forwards; }
        @keyframes popIn { to { opacity: 1; transform: translateY(0); } }

        table { width: 100%; border-collapse: collapse; font-size: 11px; }
        th { text-align: center; color: var(--accent-primary); padding: 8px 4px; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        td { padding: 4px; }
        
        #ai-prompt { background: rgba(255, 145, 0, 0.05); border: 1px solid var(--accent-primary); color: #fff; font-family: var(--font-ui); margin-bottom: 8px; }
        #ai-prompt::placeholder { color: #886644; }
    </style>
</head>
<body>

<div id="app-container">
    <div id="sidebar">
        <div class="header">
            <h1>RevoLab <span style="font-size:10px; opacity:0.5; font-weight:400; border:1px solid #555; padding:2px 4px; border-radius:3px;">V6.6 HARDWARE</span></h1>
            <h2>Advanced Robotics Core</h2>
        </div>

        <div class="tabs">
            <button class="tab-btn active" onclick="UI.switchTab('setup')">Setup</button>
            <button class="tab-btn" onclick="UI.switchTab('control')">Control</button>
            <button class="tab-btn" onclick="UI.switchTab('script')">Script</button>
            <button class="tab-btn" onclick="UI.switchTab('code')">Export</button>
        </div>

        <!-- SETUP -->
        <div id="tab-setup" class="tab-content panel active">
            
            <!-- HARDWARE BRIDGE (SERIAL) -->
            <div class="control-section" style="border-left: 2px solid #00e676;">
                <div class="section-title">
                    <span>Hardware Bridge (Serial)</span>
                    <span id="serial-status" style="font-size:9px; color:var(--text-muted)">DISCONNECTED</span>
                </div>
                <div class="input-group">
                    <label style="display:block; margin-bottom:5px;">USB / Serial Port</label>
                    <select id="serial-baud">
                        <option value="9600">9600 Baud</option>
                        <option value="115200" selected>115200 Baud</option>
                        <option value="57600">57600 Baud</option>
                    </select>
                    <div class="btn-grid">
                        <button class="primary" onclick="SerialBridge.connect()">Connect USB</button>
                        <button class="danger" onclick="SerialBridge.disconnect()">Close</button>
                    </div>
                    <div style="font-size:9px; color:#666; margin-top:5px; text-align:center;">
                        For Arduino, ESP32, Pico (WebSerial API)
                    </div>
                </div>
            </div>

            <!-- ROS 2 BRIDGE PANEL -->
            <div class="control-section">
                <div class="section-title">
                    <span>ROS 2 Bridge</span>
                    <span id="ros-status" style="font-size:9px; color:var(--text-muted)">OFFLINE</span>
                </div>
                <div class="input-group">
                    <input type="text" id="ros-url" value="ws://localhost:9090" placeholder="ws://localhost:9090">
                    <div class="btn-grid">
                        <button onclick="ROS.connect()">WS Connect</button>
                        <button class="danger" onclick="ROS.disconnect()">WS Disconnect</button>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Robot Configuration</div>
                <div class="input-group">
                    <label style="display:block; margin-bottom:5px;">Architecture Preset</label>
                    <select id="preset-sel" onchange="Sim.loadPreset(this.value)">
                        <option value="simple" selected>Simple 3-DOF</option>
                        <option value="ur5">UR5 (Cobot)</option>
                        <option value="scara">SCARA (Pick & Place)</option>
                    </select>
                </div>
                <div class="btn-grid">
                    <button onclick="Sim.resetCamera()">Reset View</button>
                    <button class="danger" onclick="Sim.hardReset()">Hard Reset</button>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">Appearance</div>
                <div class="row">
                    <label>Joint Color</label>
                    <input type="color" value="#ff9100" oninput="View.updateColor('joint', this.value)">
                </div>
                <div class="row">
                    <label>Link Color</label>
                    <input type="color" value="#444444" oninput="View.updateColor('link', this.value)">
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">
                    <span>DH Parameters</span>
                    <span style="font-size:9px; color:#555">Modified Denavit-Hartenberg</span>
                </div>
                <table id="dh-table">
                    <thead>
                        <tr>
                            <th title="Joint Type">Type</th>
                            <th title="Link Offset">d</th>
                            <th title="Link Length">a</th>
                            <th title="Link Twist">&alpha;</th>
                            <th title="Joint Offset">Off</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <div class="btn-grid tri" style="margin-top:10px;">
                    <button onclick="Robot.addLink()">+</button>
                    <button onclick="Robot.removeLink()">-</button>
                    <button class="primary" onclick="Robot.rebuild()">Apply</button>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Environment</div>
                <div class="row">
                    <label>Workspace</label>
                    <button onclick="Env.toggleWorkspace()">Generate 3D Hull</button>
                </div>
                <div class="row">
                    <label>Visuals</label>
                    <button onclick="View.toggleFrames()">Toggle Joint Frames</button>
                </div>
                <div class="row">
                    <label>Safety</label>
                    <div style="font-size:10px; color:#ff1744;" id="safety-status">MONITORING ACTIVE</div>
                </div>
            </div>
        </div>

        <!-- CONTROL -->
        <div id="tab-control" class="tab-content panel">
            <div class="control-section">
                <div class="section-title">Inverse Kinematics (DLS)</div>
                <div class="row">
                    <input type="number" id="ik-x" placeholder="X" value="1.0" step="0.1" oninput="Robot.liveIK()">
                    <input type="number" id="ik-y" placeholder="Y" value="1.0" step="0.1" oninput="Robot.liveIK()">
                    <input type="number" id="ik-z" placeholder="Z" value="0.5" step="0.1" oninput="Robot.liveIK()">
                </div>
                <div class="btn-grid tri" style="margin-top:10px;">
                    <button onmousedown="Robot.startJog('x', 0.05)" onmouseup="Robot.stopJog()">X+</button>
                    <button onmousedown="Robot.startJog('y', 0.05)" onmouseup="Robot.stopJog()">Y+</button>
                    <button onmousedown="Robot.startJog('z', 0.05)" onmouseup="Robot.stopJog()">Z+</button>
                    <button onmousedown="Robot.startJog('x', -0.05)" onmouseup="Robot.stopJog()">X-</button>
                    <button onmousedown="Robot.startJog('y', -0.05)" onmouseup="Robot.stopJog()">Y-</button>
                    <button onmousedown="Robot.startJog('z', -0.05)" onmouseup="Robot.stopJog()">Z-</button>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Joint Override</div>
                <div id="joint-sliders"></div>
            </div>

            <div class="control-section">
                <div class="section-title">End Effector</div>
                <div class="row">
                    <label>Gripper</label>
                    <input type="range" min="0" max="1" step="0.01" value="0" oninput="Robot.setGripper(this.value)">
                </div>
            </div>
        </div>

        <!-- SCRIPT -->
        <div id="tab-script" class="tab-content panel">
            <div class="control-section">
                <div class="section-title">Planning Settings</div>
                <div class="row">
                    <label>Use S-Curve</label>
                    <input type="checkbox" onchange="Trajectory.useSCurve = this.checked">
                </div>
            </div>

            <div class="control-section" style="border-color: var(--accent-primary);">
                <div class="section-title" style="color: var(--accent-primary);">✨ Gemini Copilot</div>
                <input type="text" id="ai-prompt" placeholder="e.g., Stack 3 crates">
                <button class="primary" onclick="AI.generateScript()">Generate RevoScript ✨</button>
            </div>

            <div class="control-section">
                <div class="section-title">RevoScript Editor</div>
                <div class="editor-wrapper">
                    <textarea id="script-area" class="code-area" spellcheck="false">
// Full Function Showcase
// Demonstrates Variables, Loops, and Motion
SPEED 80
HOME
PRINT "Initiating Demo Sequence..."

// Define workspace limits (Safe for 3-DOF)
SET $reach = 0.6
SET $height = 0.5
SET $depth = 0.4

// Phase 1: Workspace Corners
LOOP 2
  PRINT "Exploring Corners..."
  
  // Right-Front (Base + Shoulder)
  MOVE $reach $height $depth
  GRIP 1
  WAIT 200
  
  // Left-Front-Low (Full Range Sweep)
  // High speed transition
  MOVE -$reach 0.2 $depth SPEED 150
  GRIP 0
  WAIT 200
  
  // Right-Back (Negative Z axis)
  MOVE $reach $height -$depth
  
  // Left-Back
  MOVE -$reach $height -$depth
ENDLOOP

// Phase 2: Vertical Stack Logic
PRINT "Vertical Stack Test"
SET $stack_y = 0.2
HOME 

LOOP 3
  // Move to variable height
  MOVE 0.5 $stack_y 0.0
  WAIT 100
  
  // Logic check
  IF $stack_y > 0.6
    PRINT "High Reach: " + $stack_y
    GRIP 1
  ELSE
    PRINT "Low Reach: " + $stack_y
    GRIP 0
  ENDIF
  
  // Increment variable
  SET $stack_y = $stack_y + 0.3
ENDLOOP

HOME
PRINT "Demo Complete"</textarea>
                </div>
                <div id="error-box"></div>
                <div class="btn-grid">
                    <button class="primary" onclick="Script.run()">Execute</button>
                    <button class="danger" onclick="Script.stop()">Halt</button>
                </div>
            </div>
            
            <div class="control-section">
                <div class="section-title">Telemetry</div>
                <canvas id="telemetry"></canvas>
                <div style="display:flex; justify-content:space-between; font-size:9px; color:#555; margin-top:5px;">
                    <span>T-5s</span>
                    <span>NOW</span>
                </div>
            </div>
        </div>

        <!-- CODE -->
        <div id="tab-code" class="tab-content panel">
            <div class="control-section">
                <div class="section-title">Driver Export</div>
                <div class="input-group">
                    <select id="code-lang" onchange="CodeGen.generate()">
                        <option value="cpp">C++ (Generic)</option>
                        <option value="arduino">Arduino / ESP32 (Firmware)</option>
                        <option value="python">Python (NumPy)</option>
                    </select>
                </div>
                <div class="editor-wrapper">
                    <textarea id="export-area" class="code-area" readonly></textarea>
                </div>
                <button class="primary" style="margin-top:10px;" onclick="CodeGen.copy()">Copy to Clipboard</button>
            </div>
        </div>

        <div style="padding: 15px; border-top: 1px solid var(--border-color); background: #0f0f0f; text-align: center; margin-top: auto;">
            <div style="font-size: 9px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;">Created By</div>
            <div style="font-size: 12px; font-weight: 700; color: var(--text-main); letter-spacing: 0.5px;">Saif Khafajah</div>
        </div>
    </div>

    <!-- VIEWPORT -->
    <div id="viewport">
        <div id="hud-container">
            <div class="hud-panel">
                <div class="hud-label">System Status</div>
                <div class="hud-value" id="hud-status" style="color:var(--status-ok)">ONLINE</div>
            </div>
            <div class="hud-panel">
                <div class="hud-label">Tool Center Point (TCP)</div>
                <div class="hud-value accent" id="hud-tcp">0.00, 0.00, 0.00</div>
            </div>
            <div class="hud-panel">
                <div class="hud-label">Joint Velocity (Max)</div>
                <div class="hud-value" id="hud-vel">0.0 rad/s</div>
            </div>
        </div>

        <div id="plot-overlay">
            <div class="plot-header">
                <div class="plot-title">Live Trajectory</div>
                <div class="plot-controls">
                    <button onclick="View.toggleTrailRecord()" title="Toggle 3D Trail">Trail</button>
                    <button class="danger" onclick="View.clearTrail()" title="Clear 3D">Clr 3D</button>
                    <button class="primary" onclick="Plotter.togglePause()" title="Pause 2D">||</button>
                    <button onclick="Plotter.clear()" title="Clear 2D">Clr 2D</button>
                </div>
            </div>
            <canvas id="plot-canvas"></canvas>
            <div class="plot-legend">
                <span style="color:#ff4444">■ X-Pos</span>
                <span style="color:#44ff44">■ Y-Pos</span>
                <span style="color:#4444ff">■ Z-Pos</span>
            </div>
        </div>

        <div id="toast-area"></div>
    </div>
</div>

<script>
// --- UTILITIES ---
const RAD2DEG = 180 / Math.PI;
const DEG2RAD = Math.PI / 180;
const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
const apiKey = ""; 

// --- CONFIGURATION ---
const PRESETS = {
    ur5: [
        { type:'r', d:0.4, a:0, alpha:90, offset:0, min:-360, max:360 },
        { type:'r', d:0, a:-0.425, alpha:0, offset:-90, min:-360, max:360 },
        { type:'r', d:0, a:-0.392, alpha:0, offset:0, min:-360, max:360 },
        { type:'r', d:0.1, a:0, alpha:90, offset:90, min:-360, max:360 },
        { type:'r', d:0.1, a:0, alpha:-90, offset:0, min:-360, max:360 },
        { type:'r', d:0.1, a:0, alpha:0, offset:0, min:-360, max:360 }
    ],
    scara: [
        { type:'r', d:0.4, a:0.5, alpha:0, offset:0, min:-160, max:160 },
        { type:'r', d:0.3, a:0.4, alpha:180, offset:0, min:-150, max:150 },
        { type:'p', d:0.1, a:0, alpha:0, offset:0, min:0, max:0.3 },
        { type:'r', d:0.1, a:0, alpha:0, offset:0, min:-360, max:360 }
    ],
    simple: [
        { type:'r', d:0.5, a:0, alpha:90, offset:0, min:-180, max:180 },
        { type:'r', d:0, a:0.5, alpha:0, offset:0, min:-180, max:180 },
        { type:'r', d:0, a:0.5, alpha:0, offset:0, min:-180, max:180 }
    ]
};

// --- HARDWARE BRIDGE (SERIAL) ---
const SerialBridge = {
    port: null,
    writer: null,
    connected: false,
    lastSend: 0,
    interval: 100, // 10Hz limit for Arduino serial buffers
    isSimulated: false,

    connect: async function() {
        if (!navigator.serial) {
             // Fallback for browsers without Serial
             return this.connectSimulated("API Unavailable");
        }
        try {
            this.port = await navigator.serial.requestPort();
            const baud = parseInt(document.getElementById('serial-baud').value);
            await this.port.open({ baudRate: baud });
            
            const textEncoder = new TextEncoderStream();
            const writableStreamClosed = textEncoder.readable.pipeTo(this.port.writable);
            this.writer = textEncoder.writable.getWriter();
            
            this.connected = true;
            this.isSimulated = false;
            document.getElementById('serial-status').innerText = "CONNECTED";
            document.getElementById('serial-status').style.color = "var(--status-ok)";
            UI.notify("Serial Connected", "ok");
        } catch(e) {
            // Handle Permission/Security Errors gracefully without spamming console
            if (e.name === 'SecurityError' || e.name === 'ReferenceError') {
                UI.notify("USB Access Blocked by Browser. Using Simulation.", "warn");
                this.connectSimulated("Restricted");
            } else if (e.name === 'NotFoundError') {
                UI.notify("No device selected.", "warn");
            } else {
                console.error(e); // Only log unexpected errors
                UI.notify("Connection Failed: " + e.message, "err");
            }
        }
    },

    connectSimulated: function(reason) {
        this.connected = true;
        this.isSimulated = true;
        document.getElementById('serial-status').innerText = "SIMULATED (" + reason + ")";
        document.getElementById('serial-status').style.color = "var(--accent-primary)"; // Orange for sim
        UI.notify("Bridge Active (Simulated)", "ok");
    },
    
    disconnect: async function() {
        this.isSimulated = false;
        if(this.writer) {
            await this.writer.close();
            this.writer = null;
        }
        if(this.port) {
            await this.port.close();
            this.port = null;
        }
        this.connected = false;
        document.getElementById('serial-status').innerText = "DISCONNECTED";
        document.getElementById('serial-status').style.color = "var(--text-muted)";
    },

    update: async function() {
        if(!this.connected) return;
        const now = performance.now();
        if(now - this.lastSend > this.interval) {
            this.lastSend = now;
            // Simple CSV format: J1,J2,J3,J4,Grip\n
            const packet = Robot.joints.map(j => j.toFixed(1)).join(',') + ',' + Robot.gripper.toFixed(2) + '\n';
            
            if (this.isSimulated) {
                // Just log occasionally or do nothing
                // console.log("Sim Serial TX:", packet);
            } else if (this.writer) {
                try {
                    await this.writer.write(packet);
                } catch(e) { console.error(e); }
            }
        }
    }
};

// --- ROS 2 BRIDGE INTEGRATION ---
const ROS = {
    socket: null,
    connected: false,
    lastSend: 0,
    interval: 50, // 20Hz update rate

    connect: function() {
        const url = document.getElementById('ros-url').value;
        if(this.connected) return;
        
        UI.notify("Connecting to ROS...", "warn");
        try {
            this.socket = new WebSocket(url);
            
            this.socket.onopen = () => {
                this.connected = true;
                UI.notify("ROS Bridge Connected", "ok");
                document.getElementById('ros-status').innerText = "CONNECTED";
                document.getElementById('ros-status').style.color = "var(--status-ok)";
            };

            this.socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // Protocol: { type: 'target_update', joints: [...] }
                    if (data.type === 'target_update' && Array.isArray(data.joints)) {
                        if (data.joints.length === Robot.targetJoints.length) {
                            // Update target from ROS command
                            Robot.targetJoints = data.joints;
                            UI.updateSliders();
                        }
                    }
                } catch (e) { console.error("ROS Msg Error", e); }
            };

            this.socket.onclose = () => {
                this.disconnectUI();
                UI.notify("ROS Disconnected", "warn");
            };
            
            this.socket.onerror = () => {
                this.disconnectUI();
                UI.notify("Connection Error", "err");
            };

        } catch (e) {
            UI.notify("Invalid WebSocket URL", "err");
        }
    },
    
    disconnect: function() {
        if(this.socket) this.socket.close();
        this.disconnectUI();
    },
    
    disconnectUI: function() {
        this.connected = false;
        this.socket = null;
        document.getElementById('ros-status').innerText = "OFFLINE";
        document.getElementById('ros-status').style.color = "var(--text-muted)";
    },

    update: function() {
        if (!this.connected) return;
        const now = performance.now();
        if (now - this.lastSend > this.interval) {
            this.lastSend = now;
            // Protocol: Send current state
            const payload = {
                joint_names: Robot.dh.map((_,i) => `joint_${i+1}`),
                positions: Robot.joints,
                timestamp: now
            };
            this.socket.send(JSON.stringify(payload));
        }
    }
};

// --- COLLISION SYSTEM (V6.3 Optimized) ---
const Collision = {
    linkRadius: 0.04, // Reduced radius for fewer self-collisions
    
    distSegmentSegment: function(p1, p2, p3, p4) {
        const u = new THREE.Vector3().subVectors(p2, p1);
        const v = new THREE.Vector3().subVectors(p4, p3);
        const w = new THREE.Vector3().subVectors(p1, p3);
        const a = u.dot(u); const b = u.dot(v); const c = v.dot(v);
        const d = u.dot(w); const e = v.dot(w); const D = a * c - b * b;
        let sc, sN, sD = D; let tc, tN, tD = D;

        if (D < 0.0001) { sN = 0.0; sD = 1.0; tN = e; tD = c; } 
        else { sN = (b * e - c * d); tN = (a * e - b * d); if (sN < 0.0) { sN = 0.0; tN = e; tD = c; } else if (sN > sD) { sN = sD; tN = e + b; tD = c; } }

        if (tN < 0.0) { tN = 0.0; if (-d < 0.0) sN = 0.0; else if (-d > a) sN = sD; else { sN = -d; sD = a; } } 
        else if (tN > tD) { tN = tD; if ((-d + b) < 0.0) sN = 0; else if ((-d + b) > a) sN = sD; else { sN = (-d + b); sD = a; } }
        sc = (Math.abs(sN) < 0.0001 ? 0.0 : sN / sD); tc = (Math.abs(tN) < 0.0001 ? 0.0 : tN / tD);

        const dP = new THREE.Vector3().addVectors(w, u.multiplyScalar(sc)).sub(v.multiplyScalar(tc));
        return dP.lengthSq();
    },
    
    distPointSegment: function(point, p1, p2) {
        const ab = new THREE.Vector3().subVectors(p2, p1); const ap = new THREE.Vector3().subVectors(point, p1);
        let t = ap.dot(ab) / ab.dot(ab); t = clamp(t, 0, 1);
        const closest = new THREE.Vector3().copy(p1).add(ab.multiplyScalar(t));
        return point.distanceToSquared(closest);
    },
    
    check: function(chain) {
        const collisions = []; const limitSq = (this.linkRadius * 2) ** 2; const floorLim = this.linkRadius; 
        const segments = [];
        for(let i=0; i<chain.length-1; i++) segments.push({ start: chain[i].pos, end: chain[i+1].pos, idx: i });

        for(let s of segments) { if (s.idx === 0) continue; if(s.start.y < floorLim || s.end.y < floorLim) collisions.push({type:'floor', idx: s.idx}); }
        for(let i=0; i<segments.length; i++) {
            for(let j=i+2; j<segments.length; j++) {
                const dist2 = this.distSegmentSegment(segments[i].start, segments[i].end, segments[j].start, segments[j].end);
                if(dist2 < limitSq) { collisions.push({type:'self', idx: i, other: j}); collisions.push({type:'self', idx: j, other: i}); }
            }
        }
        if(Env.crate) {
            const cratePos = new THREE.Vector3();
            Env.crate.getWorldPosition(cratePos); // FIX: Use world pos for attached objects
            const crateRad = 0.15; const safeDistSq = (this.linkRadius + crateRad) ** 2;
            for(let s of segments) { const d2 = this.distPointSegment(cratePos, s.start, s.end); if(d2 < safeDistSq) collisions.push({type:'object', idx: s.idx}); }
        }
        return collisions.length > 0 ? collisions : null;
    }
};

const Trajectory = {
    active: false, startTime: 0, duration: 0, startJoints: [], endJoints: [],
    accelTime: 0, cruiseTime: 0, maxDist: 0, GLOBAL_VEL: 90, currentVelLimit: 90, MAX_ACC: 150, useSCurve: false,

    plan: function(current, target, speedOverride) {
        let maxDist = 0;
        for(let i=0; i<current.length; i++) { let d = Math.abs(target[i] - current[i]); if(d > maxDist) maxDist = d; }
        if(maxDist < 0.001) { this.active = false; return; }
        this.maxDist = maxDist;
        this.currentVelLimit = speedOverride ? parseFloat(speedOverride) : this.GLOBAL_VEL;

        let t_acc = this.currentVelLimit / this.MAX_ACC; let d_acc = 0.5 * this.MAX_ACC * t_acc * t_acc;
        if (maxDist < 2 * d_acc) { t_acc = Math.sqrt(maxDist / this.MAX_ACC); this.accelTime = t_acc; this.cruiseTime = 0; this.duration = 2 * t_acc; } 
        else { let d_cruise = maxDist - 2 * d_acc; let t_cruise = d_cruise / this.currentVelLimit; this.accelTime = t_acc; this.cruiseTime = t_cruise; this.duration = 2 * t_acc + t_cruise; }
        if (this.useSCurve) this.duration *= 1.2;

        this.startJoints = [...current]; this.endJoints = [...target];
        this.startTime = performance.now() / 1000; this.active = true;
    },
    update: function() {
        if(!this.active) return null;
        const now = performance.now() / 1000; const t = now - this.startTime;
        if(t >= this.duration) { this.active = false; return this.endJoints; }
        let s = 0;
        if(this.useSCurve) { let x = t / this.duration; s = x * x * (3 - 2 * x); } 
        else {
            let d = 0;
            if (t < this.accelTime) d = 0.5 * this.MAX_ACC * t * t;
            else if (t < this.accelTime + this.cruiseTime) { let v_peak = this.MAX_ACC * this.accelTime; let d_acc = 0.5 * this.MAX_ACC * this.accelTime * this.accelTime; d = d_acc + v_peak * (t - this.accelTime); } 
            else { let t_rem = this.duration - t; d = this.maxDist - 0.5 * this.MAX_ACC * t_rem * t_rem; }
            s = d / this.maxDist;
        }
        s = Math.max(0, Math.min(1, s));
        const currentQ = [];
        for(let i=0; i<this.startJoints.length; i++) { let val = this.startJoints[i] + (this.endJoints[i] - this.startJoints[i]) * s; currentQ.push(val); }
        return currentQ;
    }
};

const Robot = {
    dh: [], joints: [], targetJoints: [], gripper: 0, holdingObject: null,
    
    init: function(presetName) {
        this.dh = JSON.parse(JSON.stringify(PRESETS[presetName]));
        this.joints = new Array(this.dh.length).fill(0);
        this.targetJoints = new Array(this.dh.length).fill(0);
        UI.buildDHTable(); UI.buildSliders(); View.rebuildRobotModel();
    },

    dhMatrix: function(theta, d, a, alpha) {
        const ct = Math.cos(theta), st = Math.sin(theta); const ca = Math.cos(alpha), sa = Math.sin(alpha);
        return new THREE.Matrix4().set(ct, -st*ca, st*sa, a*ct, st, ct*ca, -ct*sa, a*st, 0, sa, ca, d, 0, 0, 0, 1);
    },

    forwardKinematics: function(joints) {
        const transforms = []; let T = new THREE.Matrix4().makeRotationX(-Math.PI/2); 
        transforms.push({ pos: new THREE.Vector3(0,0,0), mat: T.clone() });
        for(let i=0; i<this.dh.length; i++) {
            const p = this.dh[i]; const q = joints[i];
            let val = (p.type === 'r') ? (q * DEG2RAD) : q; let offset = (p.type === 'r') ? (p.offset * DEG2RAD) : 0; let alpha = p.alpha * DEG2RAD;
            let mat = (p.type === 'r') ? this.dhMatrix(val + offset, p.d, p.a, alpha) : this.dhMatrix(offset, p.d + val, p.a, alpha);
            T.multiply(mat); transforms.push({ pos: new THREE.Vector3().setFromMatrixPosition(T), mat: T.clone() });
        }
        return transforms;
    },

    // Pure mathematical IK Solver (No side effects on Robot.joints)
    computeIK: function(targetPos, startJoints) {
        let q = [...startJoints];
        
        // SAFETY: Return immediately if inputs are invalid to prevent disappearance
        if (isNaN(targetPos.x) || isNaN(targetPos.y) || isNaN(targetPos.z)) {
            console.error("IK Error: Target is NaN");
            return { success: false, joints: q, error: 999 };
        }

        // Increased iterations for complex moves
        const MAX_ITER = 60; 
        const THRESHOLD = 0.005; 
        const LAMBDA = 0.6; 
        const LAMBDA_SQ = LAMBDA * LAMBDA; 
        const MAX_STEP = 5.0; // Max degrees per iteration
        
        let success = false;
        let finalErr = 0;

        for(let iter=0; iter<MAX_ITER; iter++) {
            const chain = this.forwardKinematics(q);
            const tcp = chain[chain.length-1].pos;
            let err = new THREE.Vector3().subVectors(targetPos, tcp);
            const dist = err.length();
            finalErr = dist;

            if(dist < THRESHOLD) { success = true; break; }
            
            // Adaptive step size: Allow larger jumps if far away
            let scale = 0.1;
            if(dist > 0.5) scale = 0.2; 
            if(dist > 0.1) err.multiplyScalar(scale / dist);

            const jacobianCols = []; 
            for(let i=0; i<this.dh.length; i++) {
                const jointType = this.dh[i].type; const frame = chain[i]; const pivot = frame.pos;
                const zAxis = new THREE.Vector3(0,0,1).applyMatrix4(frame.mat).sub(new THREE.Vector3(0,0,0).applyMatrix4(frame.mat)).normalize();
                let col = new THREE.Vector3();
                if(jointType === 'r') { const r = new THREE.Vector3().subVectors(tcp, pivot); col.crossVectors(zAxis, r); } else col.copy(zAxis);
                jacobianCols.push(col);
            }

            const J = jacobianCols; const JJT = new THREE.Matrix3(); const el = JJT.elements;
            let m00=0, m01=0, m02=0, m11=0, m12=0, m22=0;
            for(let k=0; k<J.length; k++) { m00+=J[k].x*J[k].x; m01+=J[k].x*J[k].y; m02+=J[k].x*J[k].z; m11+=J[k].y*J[k].y; m12+=J[k].y*J[k].z; m22+=J[k].z*J[k].z; }
            m00+=LAMBDA_SQ; m11+=LAMBDA_SQ; m22+=LAMBDA_SQ;
            el[0]=m00; el[1]=m01; el[2]=m02; el[3]=m01; el[4]=m11; el[5]=m12; el[6]=m02; el[7]=m12; el[8]=m22;
            JJT.invert(); 
            const vec = err.clone().applyMatrix3(JJT);

            for(let i=0; i<this.dh.length; i++) {
                const delta = J[i].dot(vec); const limit = this.dh[i];
                let change = (limit.type === 'r') ? delta * RAD2DEG : delta;
                change = clamp(change, -MAX_STEP, MAX_STEP);
                q[i] = clamp(q[i] + change, limit.min, limit.max);
            }
        }
        return { success, joints: q, error: finalErr };
    },

    solveIK: function(targetPos) {
        // Use the same core logic for live IK
        const result = this.computeIK(targetPos, this.targetJoints);
        
        // V6.5 CHANGE: Safety check REMOVED.
        // We always apply the calculated joints, ignoring collisions.
        this.targetJoints = result.joints;
        
        UI.updateSliders();
    },

    liveIK: function() {
        const x = parseFloat(document.getElementById('ik-x').value) || 0;
        const y = parseFloat(document.getElementById('ik-y').value) || 0;
        const z = parseFloat(document.getElementById('ik-z').value) || 0;
        View.updateGhost(new THREE.Vector3(x,y,z));
        this.solveIK(new THREE.Vector3(x,y,z));
    },

    startJog: function(axis, amount) {
        if(this.jogInterval) clearInterval(this.jogInterval);
        this.jogInterval = setInterval(() => {
            const el = document.getElementById(`ik-${axis}`);
            let val = parseFloat(el.value) + amount;
            el.value = val.toFixed(2);
            this.liveIK();
        }, 50);
    },
    stopJog: function() { clearInterval(this.jogInterval); },

    setGripper: function(val) { this.gripper = parseFloat(val); },

    addLink: function() { this.dh.push({type:'r', d:0.2, a:0.2, alpha:0, offset:0, min:-180, max:180}); this.joints.push(0); this.targetJoints.push(0); UI.buildDHTable(); UI.buildSliders(); View.rebuildRobotModel(); },
    removeLink: function() { if(this.dh.length > 2) { this.dh.pop(); this.joints.pop(); this.targetJoints.pop(); UI.buildDHTable(); UI.buildSliders(); View.rebuildRobotModel(); } },
    rebuild: function() { View.rebuildRobotModel(); UI.notify("Kinematics Updated", "ok"); }
};

const View = {
    scene: null, camera: null, renderer: null, controls: null,
    meshes: { parts: [], gripper: null, ghost: null, crate: null, trail: null, frames: [], fingers: [] },
    showFrames: false, recordingTrail: true, lastTime: 0,
    
    init: function() {
        const el = document.getElementById('viewport');
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(45, el.clientWidth/el.clientHeight, 0.1, 100);
        this.camera.position.set(3, 2.5, 3);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(el.clientWidth, el.clientHeight);
        this.renderer.shadowMap.enabled = true; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        el.appendChild(this.renderer.domElement);
        
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true; this.controls.target.set(0, 0.5, 0);
        
        this.buildEnvironment(); this.buildMaterials();
        window.addEventListener('resize', () => this.onResize());
        this.animate(0);
    },

    materials: {},
    buildMaterials: function() {
        this.materials.body = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.8 });
        this.materials.joint = new THREE.MeshStandardMaterial({ color: 0xff9100, roughness: 0.4, metalness: 0.5, emissive: 0xff4400, emissiveIntensity: 0.1 });
        this.materials.link = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.7, metalness: 0.2 });
        this.materials.ghost = new THREE.MeshBasicMaterial({ color: 0xff9100, wireframe: true, transparent: true, opacity: 0.2 });
        this.materials.error = new THREE.MeshStandardMaterial({ color: 0xff1744, emissive: 0xff1744, emissiveIntensity: 0.5, roughness:0.2 });
    },

    buildEnvironment: function() {
        const grid = new THREE.GridHelper(20, 20, 0x333333, 0x111111); this.scene.add(grid);
        const geo = new THREE.PlaneGeometry(50, 50); const mat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1, metalness: 0.5 });
        const floor = new THREE.Mesh(geo, mat); floor.rotation.x = -Math.PI/2; floor.position.y = -0.01; floor.receiveShadow = true; this.scene.add(floor);
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const spot = new THREE.SpotLight(0xff9100, 2); spot.position.set(5, 8, 5); spot.castShadow = true; spot.shadow.bias = -0.0001; this.scene.add(spot);
        const rim = new THREE.PointLight(0x00e676, 0.5); rim.position.set(-5, 2, -5); this.scene.add(rim);
        
        this.meshes.ghost = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), this.materials.ghost); this.scene.add(this.meshes.ghost);
        const trailGeo = new THREE.BufferGeometry(); const positions = new Float32Array(5000 * 3); 
        trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const trailMat = new THREE.LineBasicMaterial({ color: 0xff9100, transparent: true, opacity: 0.5 });
        this.meshes.trail = new THREE.Line(trailGeo, trailMat); this.meshes.trail.frustumCulled = false; this.meshes.trail.geometry.setDrawRange(0, 0); this.scene.add(this.meshes.trail);
    },

    rebuildRobotModel: function() {
        if (this.meshes.parts) this.meshes.parts.forEach(part => { if (part.mesh) this.scene.remove(part.mesh); });
        if (this.meshes.frames) this.meshes.frames.forEach(f => this.scene.remove(f));
        if (this.meshes.gripper) this.scene.remove(this.meshes.gripper);
        this.meshes.parts = []; this.meshes.frames = [];

        const baseFrame = new THREE.AxesHelper(0.15); baseFrame.visible = this.showFrames; this.scene.add(baseFrame); this.meshes.frames.push(baseFrame);
        for(let i=0; i<Robot.dh.length; i++) {
            const p = Robot.dh[i];
            const hubGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.15, 32); hubGeo.rotateX(Math.PI/2);
            const hub = new THREE.Mesh(hubGeo, this.materials.joint); hub.castShadow = true; this.scene.add(hub); this.meshes.parts.push({ type:'joint', mesh:hub });
            const length = 1; const armGeo = new THREE.BoxGeometry(0.08, 0.08, length); armGeo.translate(0, 0, length/2); 
            const arm = new THREE.Mesh(armGeo, this.materials.link); arm.castShadow = true; this.scene.add(arm); this.meshes.parts.push({ type:'link', mesh:arm });
            const axis = new THREE.AxesHelper(0.15); axis.visible = this.showFrames; this.scene.add(axis); this.meshes.frames.push(axis);
        }
        const gripGroup = new THREE.Group(); const base = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.05), this.materials.body); gripGroup.add(base);
        const f1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.12, 0.02), this.materials.joint); f1.position.set(0.04, 0.1, 0); gripGroup.add(f1);
        const f2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.12, 0.02), this.materials.joint); f2.position.set(-0.04, 0.1, 0); gripGroup.add(f2);
        this.scene.add(gripGroup); this.meshes.gripper = gripGroup; this.meshes.fingers = [f1, f2];
    },

    updateGhost: function(pos) { 
        if(this.meshes.ghost) {
            this.meshes.ghost.position.copy(pos); 
            this.meshes.ghost.visible = true; 
        }
    },
    hideGhost: function() { if(this.meshes.ghost) this.meshes.ghost.visible = false; },
    
    updateColor: function(type, hex) { if(this.materials[type]) this.materials[type].color.set(hex); },
    toggleFrames: function() { this.showFrames = !this.showFrames; this.meshes.frames.forEach(f => f.visible = this.showFrames); },
    toggleTrailRecord: function() { this.recordingTrail = !this.recordingTrail; UI.notify(this.recordingTrail ? "Path Recording ON" : "Path Recording PAUSED", "ok"); },
    clearTrail: function() { this.trailCount = 0; this.meshes.trail.geometry.setDrawRange(0, 0); },

    trailIdx: 0, trailCount: 0,
    updateVisuals: function(chain) {
        if (this.meshes.frames[0]) { this.meshes.frames[0].position.copy(chain[0].pos); this.meshes.frames[0].quaternion.setFromRotationMatrix(chain[0].mat); }
        const collisions = Collision.check(chain);
        const collidedIndices = new Set();
        let statusText = "SYSTEM OK"; let statusColor = "var(--status-ok)";

        if(collisions) {
            collisions.forEach(c => { if(c.idx !== undefined) collidedIndices.add(c.idx); if(c.other !== undefined) collidedIndices.add(c.other); });
            statusText = "COLLISION DETECTED"; statusColor = "var(--status-err)";
        }
        document.getElementById('hud-status').innerText = statusText; document.getElementById('hud-status').style.color = statusColor;
        document.getElementById('safety-status').innerText = collisions ? "HALT: INTERFERENCE" : "MONITORING ACTIVE";

        for(let i=0; i<Robot.dh.length; i++) {
            const start = chain[i].pos; const end = chain[i+1].pos;
            const hub = this.meshes.parts[i*2].mesh; hub.position.copy(start); hub.quaternion.setFromRotationMatrix(chain[i].mat);
            const arm = this.meshes.parts[i*2+1].mesh; const dist = start.distanceTo(end);
            const isColliding = collidedIndices.has(i);
            arm.material = isColliding ? this.materials.error : this.materials.link; hub.material = isColliding ? this.materials.error : this.materials.joint;
            if(dist > 0.001) { arm.visible = true; arm.position.copy(start); arm.lookAt(end); arm.scale.set(1, 1, dist); } else arm.visible = false;
            if (this.meshes.frames[i+1]) { this.meshes.frames[i+1].position.copy(chain[i+1].pos); this.meshes.frames[i+1].quaternion.setFromRotationMatrix(chain[i+1].mat); }
        }
        const tcpFrame = chain[chain.length-1];
        if(this.meshes.gripper) {
            this.meshes.gripper.position.copy(tcpFrame.pos); this.meshes.gripper.quaternion.setFromRotationMatrix(tcpFrame.mat);
            const gap = 0.04 + (Robot.gripper * 0.02); this.meshes.fingers[0].position.x = gap; this.meshes.fingers[1].position.x = -gap;
        }
        if(this.recordingTrail && this.trailCount < 5000) {
            const tcp = tcpFrame.pos; const positions = this.meshes.trail.geometry.attributes.position.array;
            let shouldAdd = true;
            if (this.trailCount > 0) { const lx = positions[(this.trailCount-1)*3], ly = positions[(this.trailCount-1)*3+1], lz = positions[(this.trailCount-1)*3+2]; const d = (tcp.x-lx)**2 + (tcp.y-ly)**2 + (tcp.z-lz)**2; if(d < 0.0001) shouldAdd = false; }
            if(shouldAdd) { positions[this.trailCount * 3] = tcp.x; positions[this.trailCount * 3 + 1] = tcp.y; positions[this.trailCount * 3 + 2] = tcp.z; this.trailCount++; this.meshes.trail.geometry.attributes.position.needsUpdate = true; this.meshes.trail.geometry.setDrawRange(0, this.trailCount); }
        }
        Plotter.push(tcpFrame.pos.x, tcpFrame.pos.y, tcpFrame.pos.z);
        document.getElementById('hud-tcp').innerText = `${tcpFrame.pos.x.toFixed(2)}, ${tcpFrame.pos.y.toFixed(2)}, ${tcpFrame.pos.z.toFixed(2)}`;
    },

    animate: function(now) {
        requestAnimationFrame((t) => this.animate(t));
        
        // --- BRIDGE UPDATE ---
        ROS.update();
        SerialBridge.update();

        let maxVel = 0;
        if(Trajectory.active) {
            const newJoints = Trajectory.update();
            if(newJoints) {
                for(let i=0; i<newJoints.length; i++) { const diff = Math.abs(newJoints[i] - Robot.joints[i]); maxVel = Math.max(maxVel, diff); }
                Robot.joints = newJoints;
            }
        } else {
            for(let i=0; i<Robot.joints.length; i++) {
                const diff = Robot.targetJoints[i] - Robot.joints[i];
                if(Math.abs(diff) > 0.01) { const step = diff * 0.15; Robot.joints[i] += step; maxVel = Math.max(maxVel, Math.abs(step)); } else Robot.joints[i] = Robot.targetJoints[i];
            }
        }
        const chain = Robot.forwardKinematics(Robot.joints); this.updateVisuals(chain); this.controls.update(); this.renderer.render(this.scene, this.camera);
        Telemetry.push(maxVel); document.getElementById('hud-vel').innerText = (maxVel * 60).toFixed(1) + " deg/s";
        if(Env.crate) {
            const tcp = chain[chain.length-1].pos;
            if(Robot.gripper > 0.8 && !Robot.holdingObject) { if(tcp.distanceTo(Env.crate.position) < 0.2) { Robot.holdingObject = Env.crate; this.meshes.gripper.attach(Env.crate); } } 
            else if(Robot.gripper < 0.5 && Robot.holdingObject) { this.scene.attach(Env.crate); Robot.holdingObject = null; }
        }
    },
    
    onResize: function() {
        const el = document.getElementById('viewport');
        this.camera.aspect = el.clientWidth/el.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(el.clientWidth, el.clientHeight);
    }
};

const Plotter = {
    canvas: null, ctx: null, dataX: [], dataY: [], dataZ: [], paused: false,
    init: function() { this.canvas = document.getElementById('plot-canvas'); if(!this.canvas) return; this.ctx = this.canvas.getContext('2d'); },
    push: function(x, y, z) {
        if(this.paused) return; if(!this.ctx) this.init(); if(!this.ctx) return;
        this.dataX.push(x); this.dataY.push(y); this.dataZ.push(z);
        const maxLen = 200; if(this.dataX.length > maxLen) { this.dataX.shift(); this.dataY.shift(); this.dataZ.shift(); } this.draw();
    },
    togglePause: function() { this.paused = !this.paused; },
    clear: function() { this.dataX = []; this.dataY = []; this.dataZ = []; },
    draw: function() {
        const cvs = this.canvas; const ctx = this.ctx;
        if(cvs.width !== cvs.offsetWidth || cvs.height !== cvs.offsetHeight) { cvs.width = cvs.offsetWidth; cvs.height = cvs.offsetHeight; }
        const w = cvs.width; const h = cvs.height;
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,w,h); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
        this.drawSeries(this.dataX, '#ff4444', w, h); this.drawSeries(this.dataY, '#44ff44', w, h); this.drawSeries(this.dataZ, '#4444ff', w, h);
    },
    drawSeries: function(data, color, w, h) {
        if(data.length < 2) return; const ctx = this.ctx; ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 1.5;
        const scale = h/4; const mid = h/2; const step = w / 200;
        for(let i=0; i<data.length; i++) { const x = i * step; const y = mid - (data[i] * scale); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke();
    }
};

const AI = {
    generateScript: async function() {
        const prompt = document.getElementById('ai-prompt').value;
        if(!prompt) return UI.notify("Please enter a command", "err");
        UI.notify("Consulting Gemini...", "warn");
        const cratePos = Env.crate ? `${Env.crate.position.x.toFixed(2)}, ${Env.crate.position.y.toFixed(2)}, ${Env.crate.position.z.toFixed(2)}` : "Unknown";
        const systemPrompt = `You are an expert robot programmer for RevoScript v6.0. Context: Base 0,0,0. Crate [${cratePos}]. Task: Convert user prompt to valid RevoScript.`;
        try {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], systemInstruction: { parts: [{ text: systemPrompt }] } })
            });
            const data = await response.json(); let code = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (code) {
                code = code.replace(/```(revo|script)?/gi, '').replace(/```/g, '').trim();
                document.getElementById('script-area').value = "// Generated by Gemini ✨\n" + code;
                UI.notify("Script Generated!", "ok"); UI.switchTab('script');
            } else throw new Error("No code");
        } catch (e) { console.error(e); UI.notify("AI Request Failed", "err"); }
    }
};

const Script = {
    running: false, lines: [], pc: 0, vars: {}, loopStack: [],
    
    parse: function(raw) {
        const lines = raw.split('\n'); const clean = [];
        let loopDepth = 0, ifDepth = 0;
        
        for(let i=0; i<lines.length; i++) {
            const l = lines[i].trim();
            if(!l || l.startsWith('//')) { clean.push({cmd: 'NOOP', raw: l, lineNum: i+1}); continue; }
            
            // Tokenizer
            const tokens = []; let buffer = ""; let inString = false;
            for(let j=0; j<l.length; j++) {
                const char = l[j];
                if(char === '"') inString = !inString;
                if(char === ' ' && !inString) { if(buffer) tokens.push(buffer); buffer = ""; } 
                else buffer += char;
            }
            if(buffer) tokens.push(buffer);
            
            const upperCmd = tokens[0].toUpperCase();
            if(upperCmd === 'LOOP') loopDepth++;
            if(upperCmd === 'ENDLOOP') loopDepth--;
            if(upperCmd === 'IF') ifDepth++;
            if(upperCmd === 'ENDIF') ifDepth--;
            
            clean.push({ cmd: upperCmd, tokens: tokens, raw: l, lineNum: i+1 });
        }
        
        if(loopDepth !== 0) throw new Error("Syntax Error: Unbalanced LOOP/ENDLOOP");
        if(ifDepth !== 0) throw new Error("Syntax Error: Unbalanced IF/ENDIF");
        
        return clean;
    },

    preflight: function(cleanLines) {
        const errors = [];
        const simVars = {};
        let simJoints = [...Robot.joints];
        let steps = 0; const MAX_STEPS = 1000; let pc = 0;
        const simLoopStack = [];
        
        const resolve = (tok) => {
            if(!tok) return 0;
            if(tok.startsWith('$')) { return simVars[tok] !== undefined ? simVars[tok] : 0; }
            if(tok.startsWith('"')) return tok;
            return parseFloat(tok);
        };

        try {
            while(pc < cleanLines.length && steps < MAX_STEPS) {
                steps++; const line = cleanLines[pc];
                if(line.cmd === 'NOOP') { pc++; continue; }
                
                if(line.cmd === 'MOVE') {
                    const x = resolve(line.tokens[1]); const y = resolve(line.tokens[2]); const z = resolve(line.tokens[3]);
                    if(isNaN(x) || isNaN(y) || isNaN(z)) { errors.push(`Line ${line.lineNum}: Invalid coords`); } 
                    else {
                        const ikResult = Robot.computeIK(new THREE.Vector3(x,y,z), simJoints);
                        if(!ikResult.success) errors.push(`Line ${line.lineNum}: Target unreachable`);
                        const chain = Robot.forwardKinematics(ikResult.joints);
                        const collision = Collision.check(chain);
                        if(collision) errors.push(`Line ${line.lineNum}: Collision risk (${collision[0].type.toUpperCase()})`);
                        simJoints = ikResult.joints;
                    }
                }
                else if(line.cmd === 'SET') {
                    const varName = line.tokens[1]; let val = 0;
                    if(line.tokens[3] && ['+','-','*'].includes(line.tokens[3])) {
                        const v1 = resolve(line.tokens[2]); const v2 = resolve(line.tokens[4]);
                        if(line.tokens[3] === '+') val = v1 + v2; if(line.tokens[3] === '-') val = v1 - v2; if(line.tokens[3] === '*') val = v1 * v2;
                    } else val = resolve(line.tokens[3] || line.tokens[2]);
                    simVars[varName] = val;
                }
                else if(line.cmd === 'LOOP') { const count = parseInt(resolve(line.tokens[1])); simLoopStack.push({ startLine: pc, remaining: count }); }
                else if(line.cmd === 'ENDLOOP') {
                    if(simLoopStack.length > 0) { const ctx = simLoopStack[simLoopStack.length-1]; if(ctx.remaining > 1) { ctx.remaining--; pc = ctx.startLine + 1; continue; } else simLoopStack.pop(); }
                }
                pc++;
            }
        } catch (e) { errors.push("Sim Error: " + e.message); }
        return errors;
    },

    resolve: function(token) {
        if(!token) return 0;
        
        // FIX: Handle negative variables (e.g. -$reach)
        if (token.startsWith('-') && token.charAt(1) === '$') {
             const val = this.vars[token.substring(1)];
             if(val === undefined) throw new Error(`Undefined variable: ${token}`);
             return -parseFloat(val);
        }

        if(token.startsWith('$')) {
            const val = this.vars[token];
            if(val === undefined) throw new Error(`Undefined variable: ${token}`);
            return parseFloat(val);
        }
        if(token.startsWith('"')) return token.replace(/"/g, ''); 
        return parseFloat(token);
    },

    run: function() { 
        if(this.running) return; 
        const errBox = document.getElementById('error-box'); errBox.style.display = 'none'; errBox.innerHTML = '';
        try {
            const raw = document.getElementById('script-area').value; 
            const parsed = this.parse(raw);
            
            // V6.5 CHANGE: We run preflight to console for debug, but DO NOT show warnings to user.
            // We proceed directly to execution.
            console.log("Debug Preflight Errors:", this.preflight(parsed));
            
            UI.notify("Executing Script (Safety OFF)", "warn"); 
            
            this.lines = parsed; 
            this.pc = 0; 
            this.vars = {}; 
            this.loopStack = []; 
            this.running = true; 
            this.step(); 
        } catch(e) { UI.notify("Syntax Error: " + e.message, "err"); }
    },

    stop: function() { 
        this.running = false; 
        View.hideGhost(); 
        UI.notify("Script Stopped", "err"); 
    },

    step: function() {
        if(!this.running || this.pc >= this.lines.length) { 
            this.running = false; 
            View.hideGhost();
            return; 
        }
        const line = this.lines[this.pc];
        if(line.cmd === 'NOOP') { this.pc++; this.step(); return; }

        try {
            switch(line.cmd) {
                case 'SET':
                    const varName = line.tokens[1]; let val = 0;
                    if(line.tokens[3] && ['+','-','*'].includes(line.tokens[3])) {
                         const v1 = this.resolve(line.tokens[2]); const v2 = this.resolve(line.tokens[4]);
                         if(line.tokens[3] === '+') val = v1 + v2; if(line.tokens[3] === '-') val = v1 - v2; if(line.tokens[3] === '*') val = v1 * v2;
                    } else val = this.resolve(line.tokens[3] || line.tokens[2]);
                    this.vars[varName] = val; this.pc++; this.step(); break;

                case 'IF':
                    const lhs = this.resolve(line.tokens[1]); const op = line.tokens[2]; const rhs = this.resolve(line.tokens[3]); let res = false;
                    if(op === '>') res = lhs > rhs; if(op === '<') res = lhs < rhs; if(op === '==') res = Math.abs(lhs - rhs) < 0.001;
                    if(res) { this.pc++; this.step(); } 
                    else {
                        let depth = 1;
                        while(depth > 0 && this.pc < this.lines.length - 1) {
                            this.pc++; const l = this.lines[this.pc].cmd; if(l === 'IF') depth++; if(l === 'ENDIF') depth--;
                            if(depth === 1 && l === 'ELSE') { this.pc++; this.step(); return; }
                        }
                        this.pc++; this.step();
                    }
                    break;

                case 'ELSE':
                    let depth = 1;
                    while(depth > 0 && this.pc < this.lines.length - 1) { this.pc++; const l = this.lines[this.pc].cmd; if(l === 'IF') depth++; if(l === 'ENDIF') depth--; }
                    this.pc++; this.step(); break;
                
                case 'ENDIF': this.pc++; this.step(); break;
                case 'LOOP': const count = parseInt(this.resolve(line.tokens[1])); this.loopStack.push({ startLine: this.pc, remaining: count }); this.pc++; this.step(); break;
                case 'ENDLOOP': const ctx = this.loopStack[this.loopStack.length-1]; if(ctx.remaining > 1) { ctx.remaining--; this.pc = ctx.startLine + 1; } else { this.loopStack.pop(); this.pc++; } this.step(); break;

                case 'MOVE': 
                    const x = this.resolve(line.tokens[1]); const y = this.resolve(line.tokens[2]); const z = this.resolve(line.tokens[3]);
                    let speed = null; if(line.tokens.length > 5 && line.tokens[4].toUpperCase() === 'SPEED') speed = this.resolve(line.tokens[5]);
                    Robot.targetJoints = Robot.targetJoints; Robot.solveIK(new THREE.Vector3(x,y,z)); View.updateGhost(new THREE.Vector3(x,y,z));
                    Trajectory.plan(Robot.joints, Robot.targetJoints, speed); this.waitForMotion(); break;

                case 'SPEED': Trajectory.GLOBAL_VEL = this.resolve(line.tokens[1]); this.pc++; this.step(); break;
                case 'WAIT': setTimeout(() => { this.pc++; this.step(); }, parseInt(line.tokens[1])); break;
                case 'GRIP': Robot.setGripper(this.resolve(line.tokens[1])); setTimeout(() => { this.pc++; this.step(); }, 500); break;
                case 'PRINT': let msg = line.raw.substring(6).replace(/"/g, ''); for(let k in this.vars) { msg = msg.replace(k, this.vars[k].toFixed(2)); } UI.notify("🖨️ " + msg, "warn"); this.pc++; this.step(); break;
                case 'HOME': Robot.targetJoints = new Array(Robot.dh.length).fill(0); Trajectory.plan(Robot.joints, Robot.targetJoints); this.waitForMotion(); break;
                default: throw new Error("Unknown: " + line.cmd);
            }
        } catch(e) { UI.notify(`Error Line ${line.lineNum}: ${e.message}`, "err"); this.running = false; }
    },
    
    waitForMotion: function() { if(Trajectory.active) requestAnimationFrame(() => this.waitForMotion()); else { this.pc++; this.step(); } }
};

const Env = {
    crate: null, tent: null,
    spawnCrate: function() {
        if(this.crate) View.scene.remove(this.crate);
        const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15); const mat = new THREE.MeshStandardMaterial({ color: 0xff9100, roughness: 0.5 });
        this.crate = new THREE.Mesh(geo, mat); 
        // NEW (Matches Script):
        this.crate.position.set(0.5, 0.075, 0.0); 
        this.crate.castShadow = true; View.scene.add(this.crate);
    },
    toggleWorkspace: function() {
        if(this.tent) { View.scene.remove(this.tent); this.tent = null; return; }
        UI.notify("Generating Workspace...", "warn");
        setTimeout(() => {
            const points = [];
            for(let i=0; i<3500; i++) {
                const q = Robot.dh.map(p => (Math.random()*(p.max-p.min) + p.min));
                const chain = Robot.forwardKinematics(q); const pos = chain[chain.length-1].pos;
                if(pos.y >= 0) points.push(pos);
            }
            if(points.length > 4) {
                const geom = new THREE.ConvexGeometry(points); geom.computeVertexNormals();
                const mat = new THREE.MeshPhongMaterial({ color: 0xff9100, transparent: true, opacity: 0.15, side: THREE.DoubleSide, shininess: 90, specular: 0xffffff, flatShading: false });
                this.tent = new THREE.Mesh(geom, mat); View.scene.add(this.tent); UI.notify("Workspace Generated", "ok");
            }
        }, 50);
    }
};

const UI = {
    switchTab: function(id) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        if(window.event && window.event.target.classList.contains('tab-btn')) window.event.target.classList.add('active');
        else document.querySelector('.tab-btn').classList.add('active');
        document.getElementById(`tab-${id}`).classList.add('active');
        if(id === 'code') CodeGen.generate();
    },
    buildDHTable: function() {
        const tbody = document.querySelector('#dh-table tbody'); tbody.innerHTML = '';
        Robot.dh.forEach((p, i) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${p.type.toUpperCase()}</td><td><input type="number" value="${p.d}" onchange="Robot.dh[${i}].d=parseFloat(this.value); View.rebuildRobotModel()"></td><td><input type="number" value="${p.a}" onchange="Robot.dh[${i}].a=parseFloat(this.value); View.rebuildRobotModel()"></td><td><input type="number" value="${p.alpha}" onchange="Robot.dh[${i}].alpha=parseFloat(this.value); View.rebuildRobotModel()"></td><td><input type="number" value="${p.offset}" onchange="Robot.dh[${i}].offset=parseFloat(this.value)"></td>`;
            tbody.appendChild(tr);
        });
    },
    buildSliders: function() {
        const div = document.getElementById('joint-sliders'); div.innerHTML = '';
        Robot.dh.forEach((p, i) => {
            const row = document.createElement('div'); row.className = 'input-group';
            row.innerHTML = `<div class="row"><label>J${i+1}</label><span style="font-size:10px; color:#ff9100" id="val-j${i}">0°</span></div><input type="range" min="${p.min}" max="${p.max}" value="0" oninput="Robot.targetJoints[${i}]=parseFloat(this.value); document.getElementById('val-j${i}').innerText=this.value+'°'">`;
            div.appendChild(row);
        });
    },
    updateSliders: function() {
        Robot.targetJoints.forEach((v, i) => { 
            const el = document.querySelector(`#joint-sliders input:nth-of-type(${i+1})`);
            if (el) el.value = v;
            const label = document.getElementById(`val-j${i}`);
            if (label) label.innerText = v.toFixed(1) + '°';
        });
    },
    notify: function(msg, type) {
        const t = document.createElement('div'); t.className = 'toast'; t.innerText = msg;
        if(type==='err') t.style.borderColor = '#ff1744'; if(type==='ok') t.style.borderColor = '#00e676';
        document.getElementById('toast-area').appendChild(t); setTimeout(() => t.remove(), 3000);
    }
};

const Telemetry = {
    data: [],
    push: function(val) { this.data.push(val); if(this.data.length > 200) this.data.shift(); this.draw(); },
    draw: function() {
        const cvs = document.getElementById('telemetry'); const ctx = cvs.getContext('2d');
        const w = cvs.width = cvs.offsetWidth; const h = cvs.height = cvs.offsetHeight;
        ctx.fillStyle = '#0f0f0f'; ctx.fillRect(0,0,w,h); ctx.strokeStyle = '#ff9100'; ctx.lineWidth = 2; ctx.beginPath();
        for(let i=0; i<this.data.length; i++) { const x = (i/200)*w; const y = h - (this.data[i] * h * 5); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        ctx.stroke();
    }
};

const CodeGen = {
    generate: function() {
        const lang = document.getElementById('code-lang').value;
        let txt = "";
        if (lang === 'cpp') txt = this.cpp();
        else if (lang === 'python') txt = this.py();
        else if (lang === 'arduino') txt = this.arduino();
        document.getElementById('export-area').value = txt;
    },
    copy: function() { document.getElementById('export-area').select(); document.execCommand('copy'); UI.notify("Code Copied", "ok"); },
    cpp: function() { return `// ARC Driver C++\nstruct Config {\n` + Robot.dh.map(p => `  {${p.d}, ${p.a}, ${p.alpha}, ${p.offset}}`).join(',\n') + `\n};\n\nvoid solveIK(float x, float y, float z) { ... }`; },
    py: function() { return `import numpy as np\n\ndh_params = [\n` + Robot.dh.map(p => `    {'d':${p.d}, 'a':${p.a}, 'alpha':${p.alpha}}`).join(',\n') + `\n]\n\ndef inverse_kinematics(target):\n    pass`; },
    arduino: function() {
        const count = Robot.dh.length;
        let pins = "";
        for(let i=0; i<count; i++) pins += `Servo j${i+1};\n`;
        let attaches = "";
        for(let i=0; i<count; i++) attaches += `  j${i+1}.attach(${i+2});\n`;
        let parsing = "";
        for(let i=0; i<count; i++) parsing += `    float a${i+1} = Serial.parseFloat();\n`;
        let writing = "";
        for(let i=0; i<count; i++) writing += `    j${i+1}.write(map(a${i+1}, -180, 180, 0, 180));\n`;

        return `/* RevoLab Arduino Firmware
 * Control robot via Web Serial
 */
#include <Servo.h>

${pins}
Servo gripper;

void setup() {
  Serial.begin(115200);
  Serial.setTimeout(10);
${attaches}
  gripper.attach(${count+2});
}

void loop() {
  if (Serial.available() > 0) {
${parsing}
    float gr = Serial.parseFloat();
    
${writing}
    gripper.write(gr * 180);
  }
}`;
    }
};

const Sim = {
    loadPreset: function(p) { Robot.init(p); },
    resetCamera: function() { View.controls.reset(); },
    hardReset: function() { location.reload(); }
};

window.onload = function() { View.init(); Robot.init('simple'); };
</script>
</body>
</html>
